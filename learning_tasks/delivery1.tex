\documentclass[12pt]{article}
%\usepackage[norsk]{babel}
\usepackage[utf8]{inputenc}
\usepackage[skip=5mm]{parskip}
\usepackage{geometry} % Marginer
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[dvipsnames]{xcolor}
\usepackage{float}
\usepackage[normalem]{ulem}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{dirtytalk}
\usepackage{booktabs}
\usepackage{hyperref}

\newcommand{\task}[1]{\vspace*{5mm}\hspace*{-2cm}\fbox{#1}\\[-5mm]}
\newcommand{\subtask}[1]{\hspace*{-1cm}\textbf{(#1)}\\[-5mm]}

\title{TDT4165 Programming Languages\\Scala Project Delivery 1}
\author{\small{Random Group 4}\\ \small{Sondre T Bungum, Håvard R. Krogstie, Hermann Mørkrid}}
\date{\today}

\begin{document}
\maketitle

\task{1}
\textbf{Scala Introduction}

All the code for this task can be found in \verb|task1/Main.scala|.

\subtask{d}
The function \verb|fibonacci(n: Int)| gives the $n$'th fibonacci number,
with $0$ being the zeroth, and $1$ being the first. The rest of the seqence
is implemented using the recursive definition of fibonacci.

The function return type is \verb|BigInt| because the fibonacci sequence
quickly exceeds $2^{31}-1$, which is the maximum value representable as an \verb|Int|.
A \verb|BigInt| however does not have a pre-determined range of possible integer values.
It will allocate enough space to fit the value as it grows.

\task{2}
\textbf{Concurrency in Scala}

All the code for this task can be found in \verb|task2/Main.scala|.

\subtask{b}
The \verb|increaseCounter()| function and \verb|printCounter()| both use the variable \verb|counter|.
They perform updates and reads respectivly. When we spawn 3 threads, we don't know what order
the scheduler is going to run our threads in. Even though we have the code
%
\begin{verbatim}
val thread1 = initializeThread(increaseCounter)
val thread2 = initializeThread(increaseCounter)
val thread3 = initializeThread(printCounter)

thread1.start()
thread2.start()
thread3.start()
\end{verbatim}
%
we sometimes get \verb|1| printed to the console. This is because \verb|printCounter()|
can be called before the \verb|increaseCounter()| calls have done their job.

Another option is that the two calls to \verb|increaseCounter()| happen on top of each other,
in such a way that the two invocations of \verb|counter += 1| don't see the effects of each other.
They will both read the same old value of \verb|counter|, and thus \verb|counter| is only increased by one.

The possibilities of this occuring means the code is non-deterministic.
This kind of problem is called a race condition, which is what happens when
two threads are attempting to use the same memory address,
at least one of the threads is writing to the address,
and there is no \textbf{happens before}-relation between the two operations.

This can be very problematic in a banking system, if several deposits are made,
and multiple deposits work with the old balance, the resulting balance will not
see the effects of all the deposits.

We can avoid this by using syncronization atomics that create \textbf{happens before}
relations across threads, or use locks to avoid multpiple threads ever working on the same memory at once.

\subtask{d}
A deadlock occurs when two threads are waiting for a responce for one another.
This can be avoided by creating order so that we are always sure that an action
is finished or can be finished before or when it is required.

\end{document}
