\documentclass[12pt]{article}
%\usepackage[norsk]{babel}
\usepackage[utf8]{inputenc}
\usepackage[skip=5mm]{parskip}
\usepackage{geometry} % Marginer
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[dvipsnames]{xcolor}
\usepackage{float}
\usepackage[normalem]{ulem}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{dirtytalk}
\usepackage{booktabs}
\usepackage{hyperref}

\newcommand{\task}[1]{\vspace*{5mm}\hspace*{-2cm}\fbox{#1}\\[-5mm]}
\newcommand{\subtask}[1]{\hspace*{-1cm}\textbf{(#1)}\\[-5mm]}

\title{TDT4165 Programming Languages\\Scala Project Delivery 1}
\author{\small{Random Group 4}\\ \small{Sondre T Bungum, Håvard R. Krogstie, Hermann Mørkrid}}
\date{\today}

\begin{document}
\maketitle

\task{1}
\textbf{Scala Introduction}

All the code for this task can be found in \verb|task1/Main.scala|.

\subtask{a}
The \verb|createIntegerArray()| function declares a new array of 50 items, and then assigns those items to the numbers 1 to 50.

\subtask{b}
The \verb|sumIntegerArray(array)| function declares a variable sum, then loops over the provided array of integers to sum them.

\subtask{c}
The \verb|recursiveSumIntegerArray(array)| function first checks for the exit condition of the array being empty. If not, it sums the first element of the array with a recursive call to the function with the remainder of the array.

\subtask{d}
The function \verb|fibonacci(n: Int)| gives the $n$'th fibonacci number,
with $0$ being the zeroth, and $1$ being the first. The rest of the seqence
is implemented using the recursive definition of fibonacci.

The function return type is \verb|BigInt| because the fibonacci sequence
quickly exceeds $2^{31}-1$, which is the maximum value representable as an \verb|Int|.
A \verb|BigInt| however does not have a pre-determined range of possible integer values.
It will allocate enough space to fit the value as it grows.

\task{2}
\textbf{Concurrency in Scala}

All the code for tasks \textbf{a}, \textbf{b} and \textbf{c} can be found in \verb|task2/task2abc/Main.scala|.
The code for the last subtask \textbf{d} is in \verb|task2/task2d/Main.scala|.

\subtask{a}
The \verb|initializeThread()| function takes a function as its argument, and returns an initialized, non-started thread with the \verb|run()| method overridden by the provided function. When calling \verb|start()| on the thread later, a call will be made to this \verb|run()| function.

\subtask{b}
The \verb|increaseCounter()| function and \verb|printCounter()| both use the variable \verb|counter|.
They perform updates and reads respectivly. When we spawn 3 threads, we don't know what order
the scheduler is going to run our threads in. Even though we have the code
%
\begin{verbatim}
val thread1 = initializeThread(increaseCounter)
val thread2 = initializeThread(increaseCounter)
val thread3 = initializeThread(printCounter)

thread1.start()
thread2.start()
thread3.start()
\end{verbatim}
%
we sometimes get \verb|1| printed to the console. This is because \verb|printCounter()|
can be called before the \verb|increaseCounter()| calls have done their job.

Another option is that the two calls to \verb|increaseCounter()| happen on top of each other,
in such a way that the two invocations of \verb|counter += 1| don't see the effects of each other.
They will both read the same old value of \verb|counter|, and thus \verb|counter| is only increased by one.

The possibilities of this occuring means the code is non-deterministic.
This kind of problem is called a race condition, which is what happens when
two threads are attempting to use the same memory address,
at least one of the threads is writing to the address,
and there is no \textbf{happens before}-relation between the two operations.

This can be very problematic in a banking system, if several deposits are made,
and multiple deposits work with the old balance, the resulting balance will not
see the effects of all the deposits.

We can avoid this by using syncronization atomics that create \textbf{happens before}
relations across threads, or use locks to avoid multpiple threads ever working on the same memory at once.

\subtask{c}
\verb|increaseCounter()| and \verb|printCounter()| are made thread-safe through the implementation of \verb|safeIncreaseCounter()| and \verb|safePrintCounter()|, which each wrap the given functions in the \verb|this.synchronized()| function. \verb|this.synchronized()| makes sure that any variables operated on within the provided function are locked while operating on them, meaning that other functions are not allowed to operate on them at the same time. The \verb|this| part of the function call binds it to the context of the surrounding object, in this case \verb|Task2|.

\subtask{d}
A deadlock occurs when two threads are waiting for a responce for one another.
This can be avoided by creating order so that we are always sure that an action is finished or can be finished before or when it is required.

In our implementation, deadlock is caused by having two \verb|lazy| variables refer back to each other.

\end{document}
